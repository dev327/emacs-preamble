#+TITLE:  Emacs' Preamble
#+AUTHOR: Nikhil Gupta
#+EMAIL:  me@nikhgupta.com
#+DATE:   2013-09-21 Sun

#+DESCRIPTION:         Emacs' Preamble: Configuration for Emacs in a literal-programming (self-documenting) style.
#+KEYWORDS:            org babel emacs configuration
#+OPTIONS:             toc:3 todo:t html-style:nil
#+EXPORT_SELECT_TAGS:  export
#+EXPORT_EXCLUDE_TAGS: noexport notangle

#+HTML_HEAD: <link rel="stylesheet" href="http://www.cs.berkeley.edu/~prmohan/emacs/highlight/styles/dark.css" />
#+HTML_HEAD: <script type="text/javascript" src="http://www.cs.berkeley.edu/~prmohan/emacs/highlight/highlight.pack.js"></script>

* Motivation
  I have been a long-time [[http://www.vim.org][vim]] user, and started using [[http://gnu.org/s/emacs][Emacs]] because of the awesome [[http://orgmode.org][org-mode]]
  functionality, it provides. Definitely, I have been impressed. People were right /for once/! I
  have, only, been using Emacs for a couple of weeks, and I'm already in love with it, primarily,
  because:
  - it has the neatest organizer in this world: the =org-mode=.
  - it uses =elisp= to programmatically change itself.

  So, soon I was dwelling inside the dark world of getting my new editor resonate with myself. I
  tried several starter packages, /viz./:
  - [[http://github.com/overtone/emacs-live][Emacs Live]]
  - [[http://github.com/bbatsov/prelude][Emacs Prelude]]
  - [[http://eschulte.github.io/emacs24-starter-kit/][Emacs Starter Kit]]
  - [[http://github.com/purcell/emacs.d][@purcell's emacs configuration]]

  And, I really enjoyed my couple of days of flirting with these chicks, and they were really nice
  to me, but somehow, they were not my type. I would, definitely, enjoying dating someone else'
  girl, but the joy, the excitement, and the wilderness someone made for you, from head to toe, is
  an entirely different matter altogether. You would kill for such beauty.

  #+BEGIN_QUOTE
  My editor felt like someone else' baby in my hands - it was adorable, and cute and what not, but
  it wasn't bringing out the wickedness that resides in me. :)
  #+END_QUOTE

  So, I started working on my own take at Emacs' configuration, finally, and proudly called it
  [[http://github.com/nikhgupta/preamble][Emacs' Preamble]] - made it, remade it, and remade it again and again and each time, I switched the
  way it represented itself. I, initially, started working on it along the lines of =Prelude=, and
  then, along the lines of =@purcell's emacs.d=, but I have always like well documnted code. And,
  since, I had already seen [[http://dl.dropboxusercontent.com/u/3968124/sacha-emacs.html][Sacha Chua's Emacs Configuration]], I wanted my own configuration to be
  based upon [[http://orgmode.org/worg/org-contrib/babel/][org-babel]], as well.

* Requirements
  I am really unsure about the requirements, but I'm using this configuration on my *MacBook Pro
  '13* running on *Mac OSX 10.8.2 (Mountain Lion)*, *GNU Emacs 24.1.1*, and *org-mode v8.2*.
  (last updated on [2013-10-21 Mon])

  #+BEGIN_QUOTE
  If you intend to use this configuration for yourself, then /hopefully/, the same should work
  without giving you any headaches, if you are on a *Mac OSX*. Otherwise, feel free to pull your
  hair, but don't even dare come and blame me for your /hair losses/, later!

  *If I were you, I would experiment a lot, until I find my kinda' girl!*
  #+END_QUOTE

* Philosophy
  =org-babel= is /awesome/. It empowers Org-mode to execute source code within Org-mode
  documents. It is built upon the principles of [[http://en.wikipedia.org/wiki/Literate_programming][Literate Programming]], and can embed multiple
  languages within a single document.

  Extending upon the same, the current Org-mode file documents my configuration for Emacs, sanely
  named as *Emacs' Preamble*. The source code inside =elisp= source blocks is /tangled/ by Babel,
  and is then loaded as configuration via =org-babel-load-file= function.

  Sometimes, you will find references to =org-babel-load-file= function within source blocks in this
  file. The rationality behind this being that this configuration in its entirety reached 2000+
  lines (o'course attributable to my frequent explanations on why I did a particular thing that
  way), and therefore, I decided to divide up *Emacs' Preamble* into smaller chunks.

  This configuration for Emacs, i.e. Emacs' Preamble is heavily inspired form (in order):
  - [[https://github.com/purcell/emacs.d][@purcell's emacs.d]]

* Initialization
  [[file:init.el][It all started with a big-bang!]]
  (oh, yes! I'm a great fan of [[http://en.wikipedia.org/wiki/The_Big_Bang_Theory][The Big Bang Theory]].)

  Emacs loads up =init.el= (linked above) to read the configuration, which acts as an entry point to
  this =org-mode= file. Apart from this, =init.el= checks to see whether the Org-mode version is
  above =8.0=. If not, it upgrades Org-mode by installing it via Emacs' Package Manager, and then
  tangles and loads =elisp= source codes inside the current file by using a smart variation of
  =org-babel-load-file= function, namely =preamble/org-babel-load-file=.

  =preamble/org-babel-load-file= function makes sure that the file loading is fast, by only tangling
  the =.org= files when the configuration has changed from last known state. It does so by
  maintaining MD5 hash of the various =.org= files.

  At the moment, I leave the [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html][Emacs Server]] running on my machine, when it boots up (I, later, plan to
  run it on my VPS, and connect remotely), and use the =emacsclient= commands to connect to it. This
  way, this configuration is loaded/tangled only once, providing super-fast experience for my
  /use-cases/.

** TODO tangling should happen only when configuration changes
   I'm planning to add this feature to =init.el=, so as to increase load times even when starting
   the server. A suitable working for this can be to keep MD5 checksums for all =*.org= file in this
   directory and match them up when starting the server. If the checksums differ, we use the
   =org-babel-load-file= function to load the =.org= file, otherwise, we simply load the
   (un)compiled =.el= or =.elc= file. This function, named =preamble/org-babel-load-file= will need
   to be defined in =init.el=, and in a manner, would overload the =org-babel-load-file= function.

** TODO remove the following settings, when configuration is complete.
   #+BEGIN_SRC emacs-lisp
     (auto-fill-mode 't)
     (global-linum-mode 1)
     (xterm-mouse-mode 1)
     (setq-default fill-column 100)
   #+END_SRC
** Compatibility
   Since, this configuration uses features new to =Emacs v24=, and since I don't have time enough to
   work out a /compatible/ configuration for older version of Emacs (and not even steal them),
   display a friendly warning, if the Emacs version is below =v24=.
   #+BEGIN_SRC emacs-lisp
     ;; display an error if emacs-version is less than 24.
     (when (version< emacs-version "24")
       (error "Only Emacs version 24 and up are supported."))
   #+END_SRC

** Avoid Screen Flickers
   Now that, I have =Emacs v24= with me, I would like to first disable some of the GUI features
   early in the startup. These GUI features can cause screen to flicker otherwise, as they are
   loaded and then unloaded, making them appear for a tiny fraction of time.
   #+BEGIN_SRC emacs-lisp
     (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))     ; disable menu-bar
     (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))     ; disable tool-bar
     (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1)) ; disable scroll-bars
     (setq inhibit-startup-message 't)                    ; disable Emacs' splash screen
   #+END_SRC

** Debugging
   When working with such a configuration as this one, I often tend to pull my hair out.. This
   section helps me track down possible causes of such erratic behaviour of mine and be more
   insane, instead. Also, I hate those pesky plugins which make my Emacs' Preamble far too
   slow. This section, further, helps me benchmark my configuration for the exact same purpose.
   #+BEGIN_SRC emacs-lisp
     (setq debug-on-error 'nil)  ; set this to 'nil to disable this section
     (preamble/org-babel-load-file "core/debugger")
   #+END_SRC

** Core Functionality
   This section, basically, requires another =org-babel= [[file:./preamble/preamble-core.org][file]], which in turn, contains code that
   defines some variables, constants, macros, functions, etc. which are core to the functionality of
   Emacs' Preamble.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "added core functionality to myself.")
     (preamble/org-babel-load-file "core/basics")
     (preamble/checkpoint "added subdirectories of =./vendors= to =load-path=")
     (preamble/add-subfolders-to-load-path preamble-vendor-dir)
   #+END_SRC

** Custom File
   Emacs uses a /custom file/ to store changes done via [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html][Emacs' Easy Customization]] method. We are,
   simply, setting it up below, so that all the custom configuration exists in a separate file,
   which will not be under version control, and hence, customizable freely by anyone using Emacs'
   Preamble.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "set up location for custom file")
     (setq custom-file (expand-file-name "custom.el" preamble-dir))
     (load custom-file)
   #+END_SRC

* Packages
  OK, so I am using the default [[http://www.emacswiki.org/emacs/ELPA][Package Manager]] that is shipped with Emacs 24 to load my packages
  (anything else, does not make sense, anyways). However, I must, first, tell it to use more sources
  to search for a required package (a.k.a. =yum=):

** Repositories
   I am using [[http://www.emacswiki.org/emacs-en/Marmalade][Marmalade]], [[http://www.emacswiki.org/emacs-en/MELPA][MELPA]], & [[http://orgmode.org/elpa.html][Org ELPA]] repositories, for my purposes.
   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-archives
       '(("marmalade" . "http://marmalade-repo.org/packages/")
         ("org"       . "http://orgmode.org/elpa/")
         ("melpa"     . "http://melpa.milkbox.net/packages/")))

     (package-initialize)
     (preamble/checkpoint "added more repositories to Emacs' Package Manager")
   #+END_SRC

** On Demand Installation
   I have added some convenient functions to install a package, only when it is explicitely told to
   do so, which means that instead of writing a list of our packages (that need to be installed and
   checked on every run of Emacs) in this section, we are now able to =install= them right along
   with the rest of their configuration. This is called *On Demand Installation* of the packages.

   #+BEGIN_SRC emacs-lisp
     ;; on-demand installation of a package
     (defun preamble/require-package (package &optional min-version no-refresh)
       "Install given PACKAGE, optionally requiring MIN-VERSION.
       If NO-REFRESH is non-nil, the available package lists will not be
       re-downloaded in order to locate PACKAGE."
       (if (package-installed-p package min-version)
           t
         (if (or (assoc package package-archive-contents) no-refresh)
             (package-install package)
           (progn
             (package-refresh-contents)
             (preamble/require-package package min-version t)))))

     ;; on-demand installation of multiple packages
     (defun preamble/require-packages(packages-list)
       "Install packages from a given PACKAGES-LIST, using `preamble-require-package' function."
       (mapc #'preamble/require-package packages-list))
   #+END_SRC

* User Interface

  #+BEGIN_QUOTE
  An editor can only improve my efficiency, if it pleases my eyes.
  --- [[http://github.com/nikhgupta][Nikhil Gupta]]
  #+END_QUOTE

  This is true, since I work for almost 12-16 hours on my computer, with almost 70% time either in
  my Shell or in my Editor. And, hence, these two things need to be so adorable, and so damn
  impressive, that I would never want to leave them alone.

** Themes
   Firstly, lets add some themes to Emacs' Preamble - that way, things should get a major overhaul
   and already, help us through half the work of making it look pretty.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "installed some themes /(duh! dunno, was that even required?)/")
     (preamble/require-packages '( zenburn-theme noctilux-theme sublime-themes
                                   color-theme-sanityinc-solarized color-theme-sanityinc-tomorrow ))

     ;; quick access for some themes, I use often.
     (defun light() "Activate a light color theme."
       (interactive) (color-theme-sanityinc-solarized-light))
     (defun dark() "Activate a dark color theme."
       (interactive) (color-theme-sanityinc-solarized-dark))
     (defun eighties() "Activate an 80's theme."
       (interactive) (color-theme-sanityinc-tomorrow-eighties))

     ;; ensures that themes will be applied even if they have not been customized
     (defun preamble/reapply-themes ()
       "Forcibly load the themes listed in `custom-enabled-themes'."
       (dolist (theme custom-enabled-themes)
         (unless (custom-theme-p theme) (load-theme theme)))
       (custom-set-variables `(custom-enabled-themes (quote ,custom-enabled-themes))))

     ;; lets run the above function after Emacs has loaded this configuration.
     (add-hook 'after-init-hook 'preamble/reapply-themes)

     (preamble/checkpoint "set up a default theme")
     (setq-default custom-enabled-themes '(sanityinc-tomorrow-eighties))
   #+END_SRC

** Appearance
   I have defined some modes and settings below, that directly have an effect on the appearance of
   Emacs' Preamble. O'course, this is as per my taste, and bound to change like seasons on this
   earth.

   At the moment, =line numbers= and =column numbers= are displayed, as I really find them very
   useful. Moreover, =trailing-whitespace= is highlighted, =cursor= blinks, =continuation lines=
   are displayed, and so on..

   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "configured Emacs' Preamble for better appearance")
     (global-linum-mode 1)           ; display line numbers
     (column-number-mode 1)          ; display column number in mode line

     ;; other configuration
     (setq-default
      blink-cursor-delay 0        ; seconds after which cursor starts to blink
      blink-cursor-interval 0.4   ; length of cursor blink interval
      line-spacing 0.2            ; space to put between lines
      tooltip-delay 1.5           ; seconds to wait before displaying tooltip
      visible-bell t              ; try to flash the frame to represent bell
      truncate-lines nil          ; display continuation lines
      truncate-partial-width-windows nil)

     ;; function to adjust opacity of the current frame by some value
     (defun preamble/adjust-opacity (frame incr)
       (let* ((oldalpha (or (frame-parameter frame 'alpha) 100))
              (newalpha (+ incr oldalpha)))
         (when (and (<= frame-alpha-lower-limit newalpha) (>= 100 newalpha))
           (modify-frame-parameters frame (list (cons 'alpha newalpha))))))
   #+END_SRC

*** WhiteSpace
    I despise =whitespace=, esp. the freaky trailing ones. So, I explicitely set them to be visible,
    and automatically remove them when buffer is saved. However, I would not like to see =trailing
    whitespace= in SQLi, inf-ruby, etc.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured whitespace related settings")
      (setq show-trailing-whitespace 't)

      ;; delete trailing whitespace when buffer is saved
      (add-hook 'before-save-hook 'delete-trailing-whitespace)

      ;; do not show trailing whitespace in some modes
      (dolist (hook '(term-mode-hook comint-mode-hook compilation-mode-hook))
        (add-hook hook (lambda () (setq show-trailing-whitespace nil))))
    #+END_SRC

*** Fonts
    I am, often, working on multiple monitors, and need to increase/reduce size of my fonts. For
    that particular purpose, I have defined the following functions to increase/reduce the font
    sizes, as per my needs.

    #+BEGIN_SRC emacs-lisp
      (defun preamble/font-name-replace-size (font-name new-size)
        (let ((parts (split-string font-name "-")))
          (setcar (nthcdr 7 parts) (format "%d" new-size))
          (mapconcat 'identity parts "-")))

      (defun preamble/increment-default-font-height (delta)
        "Adjust the default font height by DELTA on every frame.
      Emacs will keep the pixel size of the frame approximately the
      same.  DELTA should be a multiple of 10, to match the units used
      by the :height face attribute."
        (let* ((new-height (+ (face-attribute 'default :height) delta))
               (new-point-height (/ new-height 10)))
          (dolist (f (frame-list))
            (with-selected-frame f
              ;; Latest 'set-frame-font supports a "frames" arg, but
              ;; we cater to Emacs 23 by looping instead.
              (set-frame-font (preamble/font-name-replace-size
                               (face-font 'default)
                               new-point-height)
                              t)))
          (set-face-attribute 'default nil :height new-height)
          (message "default font size is now %d" new-point-height)))

      (defun preamble/increase-default-font-height ()
        (interactive)
        (preamble/increment-default-font-height 10))

      (defun preamble/decrease-default-font-height ()
        (interactive)
        (preamble/increment-default-font-height -10))
    #+END_SRC

** Frame and Windows
   Frames in Emacs are, basically, today's world concept of *Windows*, i.e. an Emacs' frame is in
   naive terms the application window for Emacs. It can either be created inside Terminal by calling
   =emacsclient -t=, or as a GUI application by calling =emacsclient -c=. The code given below
   defines general settings for such a frame:

   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "ensured that condensed file name is shown as frame's title..")
     (setq frame-title-format
       '((:eval (if (buffer-file-name)
         (abbreviate-file-name (buffer-file-name)) "%b"))))

     (preamble/checkpoint "ensured that Emacs' Preamble is started maximized..")
     (custom-set-variables '(initial-frame-alist
       (quote ((fullscreen . maximized)))))
   #+END_SRC

*** Hooks                                                             :hooks:
    Since, I use both the GUI as well as the Terminal version of Emacs, depending upon the task at
    hand, I have set up two different hooks that are binded to the =after-make-frame-functions=
    hook. Furthermore, one of these hooks pertains to the GUI version, while the other one pertains
    to the Terminal version of Emacs. These hooks are run when a new frame is created by Emacs.

    #+BEGIN_SRC emacs-lisp
      (defvar preamble/after-make-console-frame-hooks '()
        "Hooks to run after creating a new TTY frame")
      (defvar preamble/after-make-window-system-frame-hooks '()
        "Hooks to run after creating a new window-system frame")

      (defun preamble/run-after-make-frame-hooks (frame)
        "Run configured hooks in response to the newly-created FRAME.
      Selectively runs either `preamble/after-make-console-frame-hooks' or
      `preamble/after-make-window-system-frame-hooks'"
        (with-selected-frame frame
          (run-hooks (if window-system
                         'preamble/after-make-window-system-frame-hooks
                       'preamble/after-make-console-frame-hooks))))

      (add-hook 'after-make-frame-functions 'preamble/run-after-make-frame-hooks)
    #+END_SRC

*** Terminal Frames                                               :tty:hooks:
    When making new Terminal, i.e. =tty= frames in Emacs, I want to ensure that I am able to use
    mouse there, as well as paste by clicking mouse middle button.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'preamble/after-make-console-frame-hooks
        (lambda ()
          (preamble/checkpoint "enabled mouse support in terminal session..")
          (xterm-mouse-mode 1)
          (when (fboundp 'mwheel-install) (mwheel-install))))
    #+END_SRC

*** GUI Frames                                                          :gui:
    When making new GUI frames in Emacs, I want to disable certain GUI features, as well as add some
    customizations pertaining to the Emacs GUI.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "suppressed some GUI features, I really hated..")
      (setq use-file-dialog 'nil) ; use mini-buffer for file dialogs
      (setq use-dialog-box  'nil) ; use mini-buffer for everythin' else..
      (eval '(setq inhibit-startup-echo-area-message "nikhgupta"))

      ;; show an indicator in left fringe for lines not in buffer
      (setq indicate-empty-lines t)
    #+END_SRC

*** Windows                                                   :modes:package:
    Switching windows, when more than 2 of them are open, with =C-x o= is a real pain in the fingers
    and eyes, therefore, I make use of the really nice [[http://github.com/dimitri/switch-window][switch-window]] package, as well as the
    =winner-mode= built-in Emacs. Winner Mode allows us to /undo/ (and /redo/) changes in the window
    configuration with the key commands =C-c left=, and =C-c right= (which, is pretty neat!)

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "activated Winner Mode..")
      (when (fboundp 'winner-mode) (winner-mode 1))

      (preamble/checkpoint "configured `switch-window' package..")
      (preamble/require-package 'switch-window)
      (require 'switch-window)

      ;; we must bind the "C-x o" key appropriately, now.
      (setq switch-window-shortcut-style 'quail)
    #+END_SRC

    Define a really handy function to quickly split the current window to open the most recent
    buffer.
    #+BEGIN_SRC emacs-lisp
      ;; Borrowed from http://postmomentum.ch/blog/201304/blog-on-emacs
      (defun preamble/split-window()
        "Split the window to see the most recent buffer in the other window.
      Call a second time to restore the original window configuration."
        (interactive)
        (if (eq last-command 'preamble/split-window)
            (progn
              (jump-to-register :preamble/split-window)
              (setq this-command 'preamble/unsplit-window))
          (window-configuration-to-register :preamble/split-window)
          (switch-to-buffer-other-window nil)))
    #+END_SRC

* Modules

  Modules are, basically, inventions of my own - o'course, nothin' can be really original these
  days - and, define small pieces of related code on a special behaviour, mode or feature of
  Emacs. Some of the *modules* may require a package, other ones may require more than one packages
  that group together to provide a unique combination of functionality, while others may just
  enhance configuration for some built-in Emacs' features.

  #+BEGIN_QUOTE
  Moreover, modules are also divided according to their parent feature set, i.e. to say whether they
  are used for =programming= or for =editing= purposes, etc. Such modules can be found in the
  respective sections under the heading: *Related Modules*.
  #+END_QUOTE

** New Features                                                                            :package:
   The following modules add some new feature to Emacs' Preamble, which are non-existent in the
   default GNU Emacs.

*** [[http://github.com/flycheck/flycheck][FlyCheck]]
    Flycheck is a modern on-the-fly syntax-checker for GNU Emacs, which selects syntax-checkers
    based on the major mode of the current buffer.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured `flycheck' package..")
      (preamble/require-package 'flycheck)
      (add-hook 'after-init-hook 'global-flycheck-mode)
    #+END_SRC

*** [[http://www.emacswiki.org/emacs/AutoComplete][AutoComplete]]
    AutoComplete is an excellent auto-completion feature with popup menu for quick selection. It can
    complete words at the point from a number of different sources, and includes fuzzy-matching,
    in-built.

    I have, first, setup *AutoComplete* as the default completion function, by hooking it inside
    =auto-complete-mode=.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured `auto-complete' package..")
      (preamble/require-package 'auto-complete)
      (require 'auto-complete-config)

      (defun preamble/auto-complete-at-point ()
        "Use AutoComplete to provide completion at the current point."
        (when (and (not (minibufferp))
                   (fboundp 'auto-complete-mode)
                   auto-complete-mode)
          (auto-complete)))

      ;; hook AC into completion-at-point
      (defun preamble/set-auto-complete-as-completion-at-point-function ()
        "Set AutoComplete as Completion-At-Point function."
        (add-to-list 'completion-at-point-functions 'preamble/auto-complete-at-point))

      (add-hook 'auto-complete-mode-hook
        'preamble/set-auto-complete-as-completion-at-point-function)
    #+END_SRC

    Next, I want to customize the behavior of *AutoComplete* to match my workflow, and have setup
    =TAB= key to trigger completions.

    #+BEGIN_SRC emacs-lisp
      (after 'auto-complete
        (global-auto-complete-mode t)       ; enable auto-complete mode globally
        (setq ac-expand-on-auto-complete t) ; auto-complete whole match on TAB
        (setq ac-auto-start 3)              ; enable auto-complete after 3 chars
        (setq ac-dwim nil)                  ; to get pop-ups with docs even if a
                                            ; word is uniquely completed

        ;; use Emacs' built-in TAB completion hooks to trigger AC (Emacs >= 23.2)
        (setq tab-always-indent 'complete)  ;; use 't when auto-complete is disabled
        (add-to-list 'completion-styles 'initials t))
    #+END_SRC

    Also, exclude very large buffers to interfere with AutoComplete, as this can slow down
    AutoComplete significantly.

    #+BEGIN_SRC emacs-lisp
      (defun preamble/dabbrev-friend-buffer (other-buffer)
        "Set OTHER-BUFFER as known to `dabbrev' only if its smaller than a given size."
        (< (buffer-size other-buffer) (* 1 1024 1024)))

      (after 'auto-complete
        (setq dabbrev-friend-buffer-function 'preamble/dabbrev-friend-buffer))
    #+END_SRC

    Finally, define some sources for AutoComplete, and setup some modes to use AutoComplete, by
    default.

    #+BEGIN_SRC emacs-lisp
      (after 'auto-complete
        ;; define sources for auto-completion
        (set-default 'ac-sources '( ac-source-imenu ac-source-dictionary
                                    ac-source-words-in-buffer
                                    ac-source-words-in-same-mode-buffers
                                    ac-source-words-in-all-buffer))

        ;; add various modes to auto-complete
        (dolist (mode '(magit-log-edit-mode log-edit-mode org-mode
                        text-mode haml-mode ruby-mode sass-mode yaml-mode
                        csv-mode espresso-mode haskell-mode html-mode
                        nxml-mode sh-mode smarty-mode clojure-mode
                        lisp-mode textile-mode markdown-mode tuareg-mode
                        js3-mode css-mode less-css-mode sql-mode
                        ielm-mode))
          (add-to-list 'ac-modes mode)))
    #+END_SRC

*** [[https://github.com/purcell/mmm-mode][Multiple Major Modes]] (mmm-mode)
    MMM Mode is a minor mode for Emacs that allows Multiple Major Modes to coexist in one buffer. It
    is well-suited to editing:
    - Preprocessed code, e.g. server-side Ruby, Perl or PHP embedded in HTML
    - Code generating code, such as HTML output by CGI scripts
    - Embedded code, such as Javascript in HTML
    - Literate programming: code interspersed with documentation, e.g. Noweb

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured `mmm-mode' package..")
      (preamble/require-package 'mmm-mode)
      (require 'mmm-auto)
      (setq mmm-global-mode 't) ;'buffers-with-submode-classes)
      (setq mmm-submode-decoration-level 2)

      ;; css embedding in html
      (after 'mmm-vars
            (mmm-add-group
             'html-css
             '((css-cdata
                :submode css-mode
                :face mmm-code-submode-face
                :front "<style[^>]*>[ \t\n]*\\(//\\)?<!\\[CDATA\\[[ \t]*\n?"
                :back "[ \t]*\\(//\\)?]]>[ \t\n]*</style>"
                :insert ((?j js-tag nil @ "<style type=\"text/css\">"
                             @ "\n" _ "\n" @ "</script>" @)))
               (css
                :submode css-mode
                :face mmm-code-submode-face
                :front "<style[^>]*>[ \t]*\n?"
                :back "[ \t]*</style>"
                :insert ((?j js-tag nil @ "<style type=\"text/css\">"
                             @ "\n" _ "\n" @ "</style>" @)))
               (css-inline
                :submode css-mode
                :face mmm-code-submode-face
                :front "style=\""
                :back "\"")))
            (dolist (mode (list 'html-mode 'nxml-mode))
              (mmm-add-mode-ext-class mode "\\.r?html\\(\\.erb\\)?\\'" 'html-css)))
    #+END_SRC

*** TODO activating =mmm-mode= gives error
    Error occurred is: =Can't preview LaTex fragment in a non-file buffer=
*** TODO Implement some =mmm= modes by taking help from [[https://github.com/purcell/mmm-mode/blob/master/mmm-sample.el][samples]].
*** [[http://www.emacswiki.org/emacs/DiminishedModes][Diminished Modes]]
    Diminished modes is an internal feature, which lets us fight mode-line clutter by diminishing
    (removing or abbreviating) minor mode indicators in there.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured Diminished Modes..")
      (preamble/require-package 'diminish)
    #+END_SRC

*** [[https://github.com/alpaker/Fill-Column-Indicator][Fill Column Indicator]]
    #+BEGIN_QUOTE
      Many modern editors and IDEs can graphically indicate the location of the fill column by
      drawing a thin line (in design parlance, a "rule") down the length of the editing
      window. Fill-column-indicator implements this facility in Emacs.
    #+END_QUOTE

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured Fill Column Indicator..")
      (preamble/require-package 'fill-column-indicator)
      (after 'fill-column-indicator
        (setq fci-rule-width 10)
        (setq fci-rule-character ?❚)
      ; (setq fci-rule-character-color "#999999")
        (setq fci-dash-pattern 1.00))

      (defun preamble/fci-mode-settings()
        (turn-on-fci-mode)
        (when show-trailing-whitespace
          (set (make-local-variable 'whitespace-style) '(face trailing))
          (whitespace-mode 1)))

      (add-hook 'prog-mode-hook 'preamble/fci-mode-settings)
      (add-hook 'org-mode-hook  'preamble/fci-mode-settings)

      (defun preamble/fci-enabled-p ()
        (and (boundp 'fci-mode) fci-mode))

      (defvar preamble/fci-mode-suppressed nil)
      (defadvice popup-create (before suppress-fci-mode activate)
        "Suspend fci-mode while popups are visible"
        (let ((fci-enabled (preamble/fci-enabled-p)))
          (when fci-enabled
            (set (make-local-variable 'preamble/fci-mode-suppressed) fci-enabled)
            (turn-off-fci-mode))))
      (defadvice popup-delete (after restore-fci-mode activate)
        "Restore fci-mode when all popups have closed"
        (when (and preamble/fci-mode-suppressed
                   (null popup-instances))
          (setq preamble/fci-mode-suppressed nil)
          (turn-on-fci-mode)))

      ;; Regenerate fci-mode line images after switching themes
      (defadvice enable-theme (after recompute-fci-face activate)
        (dolist (buffer (buffer-list))
          (with-current-buffer buffer
            (when (preamble/fci-enabled-p)
              (turn-on-fci-mode)))))

    #+END_SRC

*** [[https://github.com/Wilfred/ag.el][The Silver Searcher]]
    [[https://github.com/ggreer/the_silver_searcher][The Silver Searcher]] (=ag=) is an awesome utility, somewhat like =ack=, but faster. This module
    allows me to use the power of =ag= inside Emacs' Preamble.
    #+BEGIN_SRC emacs-lisp
      (when (executable-find "ag")
        (preamble/require-packages '(ag wgrep-ag))
        (setq-default ag-highlight-search t))
    #+END_SRC

** Feature Enhancements                                    :enhanced:package:
    The following modules, simply, improve upon a given feature in GNU Emacs, in order to, provide a
    more awesome experience inside Emacs' Preamble.
*** [[http://www.emacswiki.org/emacs/Dired][Dired Mode]]

    #+BEGIN_QUOTE
      [[http://www.emacswiki.org/emacs/DiredPlus][Dired+]] is /awesome/, well.. not, initially.
    #+END_QUOTE

    [[http://www.emacswiki.org/emacs/DiredPlus][Dired+]] extends functionalities provided by standard GNU Emacs libraries =dired.el=,
    =dired-aux.el=, and =dired-x.el=. The standard functions are all available, plus many more.

    *Dired+* enhances our file-exploring experience.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured Dired and DiredPlus..")
      (preamble/require-package 'dired+)

      (setq diredp-hide-details-initially-flag nil)
      (setq global-dired-hide-details-mode -1)

      (after 'dired
        (require 'dired+)
        (setq dired-recursive-deletes 'top)
        (define-key dired-mode-map [mouse-2] 'dired-find-file))
    #+END_SRC

*** [[http://www.emacswiki.org/emacs/IbufferMode][iBuffer Mode]]

    [[https://github.com/purcell/ibuffer-vc][ibuffer-vc]] adds functionality to Emacs' =ibuffer-mode= for grouping buffers by their parent VC
    (version-control) root directory, and for displaying and/or sorting by the VC status of listed
    files.

    This is to say that, my =iBuffer= will, now, show me different groups of buffers based on the
    =git= repository status. /Pretty Awesome!/

    First, lets make sure that the buffers are grouped according to version control system, they are
    in, then by filename or process name.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured `ibuffer' with `ibuffer-vc' package...")
      (preamble/require-package 'ibuffer-vc)
      (after 'ibuffer (require 'ibuffer-vc))

      (defun preamble/ibuffer-set-up-preferred-filters ()
        "Sort ibuffers according to Version Control or Filename or Process."
        (ibuffer-vc-set-filter-groups-by-vc-root)
        (unless (eq ibuffer-sorting-mode 'filename/process)
          (ibuffer-do-sort-by-filename/process)))

      (add-hook 'ibuffer-hook 'preamble/ibuffer-set-up-preferred-filters)
    #+END_SRC

    Now, the default display of =dired= command is a bit non-resonating with what my eyes want to
    see, and therefore, lets change the configuration of =ibuffer= to suit my pair of eyes.

    #+BEGIN_SRC emacs-lisp
      (after 'ibuffer
        ;; use human readable size column instead of original one
        (define-ibuffer-column size-h
          (:name "Size" :inline t)
          (cond
           ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
           ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
           (t (format "%8d" (buffer-size))))))

      ;; modify the default ibuffer-formats
      (setq ibuffer-formats
            '((mark modified read-only vc-status-mini " "
                    (name 18 18 :left :elide)
                    " "
                    (size-h 9 -1 :right)
                    " "
                    (mode 16 16 :left :elide)
                    " "
                    (vc-status 16 16 :left)
                    " "
                    filename-and-process)))

      (setq ibuffer-filter-group-name-face 'font-lock-doc-face)
    #+END_SRC

*** [[http://www.emacswiki.org/emacs/InteractivelyDoThings][IDO Mode]] and [[http://www.emacswiki.org/emacs/Smex][Smex]]

    IDO mode is, simply, amazin'! It lets us do things interactively with buffers and files. When
    combined with [[https://github.com/technomancy/ido-ubiquitous][IDO Ubiquitous]] and [[https://github.com/nonsequitur/smex][Smex]], it creates a powerful combination of fuzzy-file searching
    and the same power is available for executings commands, as well as a heap of other places.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured IDO Mode along with Smex..")
      (preamble/require-packages '( smex idomenu ido-ubiquitous))

      ;; suppress warnings from ido-ubiquitous
      (defvar predicate 'nil)
      (defvar inherit-input-method 'nil)
      (defvar ido-cur-item 'nil)
      (defvar ido-default-item 'nil)
      (defvar ido-cur-list 'nil)

      (ido-mode 't)                            ;; enable ido mode
      (ido-everywhere 't)                      ;; use ido-mode wherever possible
      (ido-ubiquitous-mode 't)                 ;; enable ido-ubiquitous
      (setq ido-enable-flex-matching 't)       ;; enable fuzzy search
      (setq ido-use-filename-at-point 'nil)    ;; look for filename at point
      (setq ido-use-virtual-buffers 't)        ;; allow me to open closed buffers, even

      ;; switch to merged work directories during file input when no match is found
      (setq ido-auto-merge-work-directories-length 0)
      ;; allow the same buffer to be open in different frames
      (setq ido-default-buffer-method 'selected-window)

      (defun preamble/ido-choose-from-recentf ()
        "Use ido to select a recently opened file from the `recentf-list'."
        (interactive)
        (if (and ido-use-virtual-buffers (fboundp 'ido-toggle-virtual-buffers))
          (ido-switch-buffer)
          (find-file (ido-completing-read "Open file: " recentf-list nil t))))
    #+END_SRC

*** [[http://www.emacswiki.org/emacs/UndoTree][UndoTree]]
    UndoTree is amazin'. It visually describes your change history for the current buffer in a nice
    ascii-tree like structure. From there, it is trivially easy to view your changes, and easily
    undo/redo according to Emacs' undo structure.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured `undo-tree' package..")
      (preamble/require-package 'undo-tree)
      (global-undo-tree-mode 1)
      (diminish 'undo-tree-mode)
    #+END_SRC
** In-built Features                                                :ehanced:
   The following modules configure a built-in feature, so as to suite to my personal taste.
*** [[http://www.emacswiki.org/emacs/IncrementalSearch][Incremental Search]]
    =isearch= is the Incremental Search feature of Emacs, and while it is really nice on its own, it
    may need some basic extensions and features related to it.

    Lets, add a function to automatically search for the current word in the buffer.
    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "Adding extra functions for `isearch' package..")

      ;; Search back/forth for the symbol at point
      ;; See http://www.emacswiki.org/emacs/SearchAtPoint
      (defun preamble/isearch-yank-symbol ()
        "*Put symbol at current point into search string."
        (interactive)
        (let ((sym (symbol-at-point)))
          (if sym
              (progn
                (setq isearch-regexp t
                      isearch-string (concat "\\_<" (regexp-quote (symbol-name sym)) "\\_>")
                      isearch-message (mapconcat 'isearch-text-char-description isearch-string "")
                      isearch-yank-flag t))
            (ding)))
        (isearch-search-and-update))
    #+END_SRC

    Lets, also, add a function to zap (kill till) the first match of the current search string.
    #+BEGIN_SRC emacs-lisp
      ;; http://www.emacswiki.org/emacs/ZapToISearch
      (defun zap-to-isearch (rbeg rend)
        "Kill the region between the mark and the closest portion of
      the isearch match string. The behaviour is meant to be analogous
      to zap-to-char; let's call it zap-to-isearch. The deleted region
      does not include the isearch word. This is meant to be bound only
      in isearch mode.  The point of this function is that oftentimes
      you want to delete some portion of text, one end of which happens
      to be an active isearch word. The observation to make is that if
      you use isearch a lot to move the cursor around (as you should,
      it is much more efficient than using the arrows), it happens a
      lot that you could just delete the active region between the mark
      and the point, not include the isearch word."
        (interactive "r")
        (when (not mark-active)
          (error "Mark is not active"))
        (let* ((isearch-bounds (list isearch-other-end (point)))
               (ismin (apply 'min isearch-bounds))
               (ismax (apply 'max isearch-bounds))
               )
          (if (< (mark) ismin)
              (kill-region (mark) ismin)
            (if (> (mark) ismax)
                (kill-region ismax (mark))
              (error "Internal error in isearch kill function.")))
          (isearch-exit)
          ))

      ;; http://www.emacswiki.org/emacs/ZapToISearch
      (defun isearch-exit-other-end (rbeg rend)
        "Exit isearch, but at the other end of the search string.
      This is useful when followed by an immediate kill."
        (interactive "r")
        (isearch-exit)
        (goto-char isearch-other-end))
    #+END_SRC

    Finally, map the above function to certain keybindings when inside =isearch-mode=. Also, make
    sure that calling =occur= is, also, easier in this mode.
    #+BEGIN_SRC emacs-lisp
      ;; put symbol at current point into search string
      (define-key isearch-mode-map "\C-\M-w" 'isearch-yank-symbol)
      ;; zap to first match of the search string
      (define-key isearch-mode-map [(meta z)] 'zap-to-isearch)
      ;; exit isearch on the other end of it, so that yank can be easier
      (define-key isearch-mode-map [(control return)] 'isearch-exit-other-end)
      ;; activate occur easily inside isearch
      (define-key isearch-mode-map (kbd "C-o") 'isearch-occur)
    #+END_SRC

*** [[http://www.emacswiki.org/emacs/uniquify][Uniquify]]
    Uniquify is a built-in library that makes buffer names unique, when two files with same name are
    open, so as to make them distinguishable.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured `uniquify' feature..")
      (require 'uniquify)

      (after 'uniquify
        (setq uniquify-buffer-name-style 'reverse)
        (setq uniquify-separator " • ")
        (setq uniquify-after-kill-buffer-p t)
        (setq uniquify-ignore-buffers-re "^\\*"))
    #+END_SRC

*** [[http://www.emacswiki.org/emacs/RecentFiles][Recent Files]]
    Recentf is a minor mode that builds a list of recently opened files. This list is is
    automatically saved across Emacs sessions. You can then access this list through a menu, or
    keybinding.

    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured `recentf' feature..")
      (require 'recentf)

      (after 'recentf
        (recentf-mode 1)
        (setq recentf-max-menu-items 25
              recentf-max-saved-items 1000
              recentf-exclude '("/tmp/" "/ssh:")))
    #+END_SRC

*** [[http://www.emacswiki.org/emacs/HippieExpand][Hippie Expand]]
    #+BEGIN_QUOTE
      HippieExpand looks at the word before point and tries to expand it in various ways including
      expanding from a fixed list (like =expand-abbrev=), expanding from matching text found in a
      buffer (like =dabbrev-expand=) or expanding in ways defined by your own functions. Which of
      these it tries and in what order is controlled by a configurable list of functions.
    #+END_QUOTE

    As stated above, =hippie-expand= uses a list of functions, which has been defined below in our
    case:
    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "configured `hippie-expand' feature..")
      (after 'hippie-expand
       (setq hippie-expand-try-functions-list
             '(try-complete-file-name-partially
               try-complete-file-name
               try-expand-dabbrev
               try-expand-dabbrev-all-buffers
               try-expand-dabbrev-from-kill)))
    #+END_SRC

** Miscelleneous
   #+BEGIN_SRC emacs-lisp
     (preamble/require-packages '(regex-tool))
   #+END_SRC
* Version Management
  Version management is the heart of my projects, in particular, [[http://git-scm.com/][git]]. This section defines various
  settings so as to allow me to version control my projects from within Emacs' Preamble.

  Enable some packages that will be required for such configuration.
  #+BEGIN_SRC emacs-lisp
    (preamble/checkpoint "enabled version management inside Emacs")
    (preamble/require-packages '(
      magit                  ;; awesome git interface inside Emacs
      git-blame              ;; emacs frontend for `git-blame' tool
      gitignore-mode         ;; major mode for gitignore
      gitconfig-mode         ;; major mode for gitconfig
      git-commit-mode        ;; major mode for git commit
      git-rebase-mode        ;; major mode for git rebase
      git-messenger          ;; display why a line was changed as per git commits
      git-gutter-fringe      ;; display git status of lines in gutter
      yagist                 ;; gist management
      github-browse-file     ;; view the file we're editing in Github
      bug-reference-github   ;; Automatically set bug-reference-url-format and enable
                             ;; bug-reference-prog-mode buffers from Github repositories.
    ))

    ;; activate `bug-reference-github' in programming mode
    (after 'bug-reference-github
      (add-hook 'prog-mode-hook 'bug-reference-prog-mode))

  #+END_SRC

  Now, all I need is to setup [[https://github.com/magit/magit][magit]] as I intend it to perform inside my workflow.
   #+BEGIN_SRC emacs-lisp
     (setq-default
      magit-save-some-buffers nil
      magit-process-popup-time 10
      magit-diff-refine-hunk t
      magit-completing-read-function 'magit-ido-completing-read)

     (after 'magit
       ;; don't let magit-status mess up window configurations
       ;; http://whattheemacsd.com/setup-magit.el-01.html
       (defadvice magit-status (around magit-fullscreen activate)
         (window-configuration-to-register :magit-fullscreen)
         ad-do-it
         (delete-other-windows))

       (defadvice magit-quit-window (around magit-restore-screen activate)
         ad-do-it
         (jump-to-register :magit-fullscreen)))

     ;;; when we start working on git-backed files, use git-wip if available
     (after 'vc-git
       (global-magit-wip-save-mode)
       (diminish 'magit-wip-save-mode))
   #+END_SRC

* Editing
** Related Modules
  Given below are some of the modules that are required for a better editing experience. Most of
  these modules have no configuration required, and may need key binding(s), which are defined in
  that section, exclusively.

  #+BEGIN_SRC emacs-lisp
    (preamble/checkpoint "installed packages to enrich editing experience, if so required")
    (preamble/require-packages
     '( unfill                ; join several lines inside a region/para
        whole-line-or-region  ; kill whole region/line based on if region is active
        mic-paren             ; matching parenthesis even if outside current screen
        pointback             ; per-window memory of buffer-point positions
        multiple-cursors      ; self-explanatory
        ace-jump-mode         ; quickly jump to a character on screen
        page-break-lines      ; display ^L page breaks as tidy horizontal lines
        move-text             ; move text easily up and down
        visual-regexp         ; get visual indications for matched regexp
        paredit               ; awesome parenthesis editing
        highlight-escape-sequences ))

    ;; settings for `highlight-escape-sequences' package
    (hes-mode 1)

    ;; settings for `page-break-lines' package
    (global-page-break-lines-mode)
    (after 'page-break-lines (diminish 'page-break-lines-mode))

    ;; settings for `pointback' package
    (global-pointback-mode 1)
    (after 'skeleton
       (defadvice skeleton-insert (before disable-pointback activate)
         "Disable pointback when using skeleton functions like `sgml-tag'."
         (when pointback-mode
           (message "Disabling pointback.")
           (pointback-mode -1))))

    ;; settings for `whole-line-or-region' package
    (whole-line-or-region-mode 1)
    (after 'whole-line-or-region
      (diminish 'whole-line-or-region-mode)
      (make-variable-buffer-local 'whole-line-or-region-mode))
  #+END_SRC
*** ParEdit
    #+BEGIN_SRC emacs-lisp
      (preamble/require-packages '(paredit paredit-everywhere))

      (autoload 'enable-paredit-mode "paredit")

      (defun maybe-map-paredit-newline ()
        (unless (or (memq major-mode '(inferior-emacs-lisp-mode nrepl-mode))
                    (minibufferp))
          (local-set-key (kbd "RET") 'paredit-newline)))

      (add-hook 'paredit-mode-hook 'maybe-map-paredit-newline)

      (after 'paredit
        (diminish 'paredit-mode " Par")
        (dolist (binding (list (kbd "C-<left>") (kbd "C-<right>")
                               (kbd "C-M-<left>") (kbd "C-M-<right>")))
          (define-key paredit-mode-map binding nil))

        ;; disable kill-sentence, which is easily confused with the kill-sexp
        ;; binding, but doesn't preserve sexp structure
        (define-key paredit-mode-map [remap kill-sentence] nil)
        (define-key paredit-mode-map [remap backward-kill-sentence] nil))

      ;; use paredit in the minibuffer
      ;; TODO: break out into separate package
      ;; http://emacsredux.com/blog/2013/04/18/evaluate-emacs-lisp-in-the-minibuffer/
      (add-hook 'minibuffer-setup-hook 'conditionally-enable-paredit-mode)

      (defvar paredit-minibuffer-commands '(eval-expression
                                            pp-eval-expression
                                            eval-expression-with-eldoc
                                            ibuffer-do-eval
                                            ibuffer-do-view-and-eval)
        "Interactive commands for which paredit should be enabled in the minibuffer.")

      (defun conditionally-enable-paredit-mode ()
        "Enable paredit during lisp-related minibuffer commands."
        (if (memq this-command paredit-minibuffer-commands)
            (enable-paredit-mode)))

      ;; enable some handy paredit functions in all prog modes
      (add-hook 'prog-mode-hook 'paredit-everywhere-mode)
    #+END_SRC
*** Spell Check
    #+BEGIN_SRC emacs-lisp
      (when *spell-check-support-enabled*
        (require 'ispell)
        (when (executable-find ispell-program-name)
          (require 'init-flyspell)))
    #+END_SRC
** General Configuration
   The following block of code sets up several configuration options for the editor.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "configured editing environment..")
     (electric-pair-mode 1)    ; automatically insert delimiter pairs
     (delete-selection-mode 1) ; typed text replaces the active selection
     (transient-mark-mode t)   ; highlight the region when mark is active
     (cua-selection-mode t)    ; for rectangular selections, CUA is nice

     (setq-default
      case-fold-search t          ; searches and matches should ignore case
      indent-tabs-mode nil        ; indentation can not insert tabs
      )
   #+END_SRC

   We do not want to disable narrowing commands, or case-change functions.

   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "enabled some disabled commands")
     (put 'narrow-to-region 'disabled nil)
     (put 'narrow-to-page 'disabled nil)
     (put 'narrow-to-defun 'disabled nil)
     (put 'upcase-region 'disabled nil)
     (put 'downcase-region 'disabled nil)
   #+END_SRC

   Next, we define some custom functions that help us in editing easily.

   #+BEGIN_SRC emacs-lisp
     (autoload 'zap-up-to-char "misc" "Kill up to, but not including
     ARGth occurrence of CHAR.")

     (defun duplicate-region (beg end)
       "Insert a copy of the current region after the region."
       (interactive "r")
       (save-excursion
         (goto-char end)
         (insert (buffer-substring beg end))))

     (defun duplicate-line-or-region (prefix)
       "Duplicate either the current line or any current region."
       (interactive "*p")
       (whole-line-or-region-call-with-region 'duplicate-region prefix t))

     (defun kill-back-to-indentation ()
       "Kill from point back to the first non-whitespace character on the line."
       (interactive)
       (let ((prev-pos (point)))
         (back-to-indentation)
         (kill-region (point) prev-pos)))

     (defun sort-lines-random (beg end)
       "Sort lines in region randomly."
       (interactive "r")
       (save-excursion
         (save-restriction
           (narrow-to-region beg end)
           (goto-char (point-min))
           (let ;; To make `end-of-line' and etc. to ignore fields.
               ((inhibit-field-text-motion t))
             (sort-subr nil 'forward-line 'end-of-line nil nil
                        (lambda (s1 s2) (eq (random 2) 0)))))))

     (defun preamble/open-line-with-reindent (n)
       "A version of `open-line' which reindents the start and end positions.
     If there is a fill prefix and/or a `left-margin', insert them
     on the new line if the line would have been blank.
     With arg N, insert N newlines."
       (interactive "*p")
       (let* ((do-fill-prefix (and fill-prefix (bolp)))
              (do-left-margin (and (bolp) (> (current-left-margin) 0)))
              (loc (point-marker))
              ;; Don't expand an abbrev before point.
              (abbrev-mode nil))
         (delete-horizontal-space t)
         (newline n)
         (indent-according-to-mode)
         (when (eolp)
           (delete-horizontal-space t))
         (goto-char loc)
         (while (> n 0)
           (cond ((bolp)
                  (if do-left-margin (indent-to (current-left-margin)))
                  (if do-fill-prefix (insert-and-inherit fill-prefix))))
           (forward-line 1)
           (setq n (1- n)))
         (goto-char loc)
         (end-of-line)
         (indent-according-to-mode)))
    #+END_SRC

* Org Mode
  Org Mode configuration is loaded from another =org-mode= [[file:./modules/org-mode.org][file]], which basically sets up required
  packages, functions, hooks, configuration, etc. for =org-mode=. This way, I am able to keep
  configuration of =org-mode= into a separate city of its own.
  #+BEGIN_SRC emacs-lisp
    (preamble/org-babel-load-file "modules/org-mode")
  #+END_SRC
* Programming
  This section contains various packages and their settings related to programming.
** Ruby Group
   The languages/modes in this section include =ruby-mode=, =rails=, =yaml=, =erb=, etc.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "enabled support for =ruby-group=")
     (preamble/require-packages '(ruby-mode ruby-hash-syntax inf-ruby
                                            robe ruby-compilation yari yaml-mode
                                            tagedit rinari))

     (add-to-list 'auto-mode-alist '("Rakefile\\'" "\\.rake\\'" "\\.rxml\\'"
                                     "\\.rjs\\'" ".irbrc\\'" "\\.builder\\'" "\\.ru\\'"
                                     "\\.gemspec\\'" "Gemfile\\'" "Kirkfile\\'" . 'ruby-mode))

     (setq ruby-use-encoding-map nil)

     (after 'ruby-mode
       (define-key ruby-mode-map (kbd "RET") 'reindent-then-newline-and-indent)
       (define-key ruby-mode-map (kbd "TAB") 'indent-for-tab-command)

       ;; stupidly the non-bundled ruby-mode isn't a derived mode of
       ;; prog-mode: we run the latter's hooks anyway in that case.
       (add-hook 'ruby-mode-hook
                 (lambda () (unless (derived-mode-p 'prog-mode) (run-hooks 'prog-mode-hook)))))

     ;; ruby compilation
     (let ((m ruby-mode-map))
       (define-key m [S-f7] 'ruby-compilation-this-buffer)
       (define-key m [f7] 'ruby-compilation-this-test)
       (define-key m [f6] 'recompile))

     ;;; robe: Code navigation, documentation and completion for Ruby
     (after 'ruby-mode (add-hook 'ruby-mode-hook 'robe-mode))
     (after 'robe (add-hook 'robe-mode-hook
       (lambda ()
         (add-to-list 'ac-sources 'ac-source-robe)
         (set-auto-complete-as-completion-at-point-function))))

     ;;; ri support
     (defalias 'ri 'yari)

     ;;; ERB
     (defun preamble/ensure-mmm-erb-loaded () (require 'mmm-erb))
     (require 'derived)

     (defun preamble/set-up-mode-for-erb (mode)
       (add-hook (derived-mode-hook-name mode) 'preamble/ensure-mmm-erb-loaded)
       (mmm-add-mode-ext-class mode "\\.erb\\'" 'erb))

     (let ((html-erb-modes '(html-mode html-erb-mode nxml-mode)))
       (dolist (mode html-erb-modes)
         (preamble/set-up-mode-for-erb mode)
         (mmm-add-mode-ext-class mode "\\.r?html\\(\\.erb\\)?\\'" 'html-js)
         (mmm-add-mode-ext-class mode "\\.r?html\\(\\.erb\\)?\\'" 'html-css)))

     (mapc 'preamble/set-up-mode-for-erb
           '(coffee-mode js-mode js2-mode js3-mode markdown-mode textile-mode))

     (after 'sgml-mode (tagedit-add-paredit-like-keybindings)) ;; tagedit
     (mmm-add-mode-ext-class 'html-erb-mode "\\.jst\\.ejs\\'" 'ejs)

     (add-to-list 'auto-mode-alist '("\\.rhtml\\'" "\\.html\\.erb\\'" . 'html-erb-mode))
     (add-to-list 'auto-mode-alist '("\\.jst\\.ejs\\'"  . html-erb-mode))
     (mmm-add-mode-ext-class 'yaml-mode "\\.yaml\\'" 'erb)

     (dolist (mode (list 'js-mode 'js2-mode 'js3-mode))
       (mmm-add-mode-ext-class mode "\\.js\\.erb\\'" 'erb))

     ;; rails
     (after 'rinari (diminish 'rinari-minor-mode "Rin"))
     (global-rinari-mode)

     (defun update-rails-ctags ()
       (interactive)
       (let ((default-directory (or (rinari-root) default-directory)))
         (shell-command (concat "ctags -a -e -f " rinari-tags-file-name " --tag-relative -R app lib vendor test"))))

   #+END_SRC
** PHP Group
   The languages/modes that belong to this group include =php=, =smarty=, etc.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "enabled support for =php-group=")
     (preamble/require-packages '(php-mode smarty-mode))
   #+END_SRC
** Javascript Group
   The languages/modes that belong to thid group include =json=, =javascript=, =coffee=, etc.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "enabled support for =javascript-group=")
     (preamble/require-packages '( json js2-mode ac-js2 rainbow-delimiters coffee-mode))

     (defvar preferred-javascript-indent-level 2)
     (defcustom preferred-javascript-mode
       (first (remove-if-not #'fboundp '(js2-mode js-mode)))
       "Javascript mode to use for .js files."
       :type 'symbol
       :group 'programming
       :options '(js2-mode js-mode))

     ;; json
     (add-to-list 'auto-mode-alist '("\\.json\\'" . js-mode))

     ;; javascript (even inside erb)
     (setq auto-mode-alist (cons `("\\.js\\(\\.erb\\)?\\'" . ,preferred-javascript-mode)
                                 (loop for entry in auto-mode-alist
                                       unless (eq preferred-javascript-mode (cdr entry))
                                       collect entry)))

     ;; js2-mode
     (setq js2-use-font-lock-faces t
           js2-mode-must-byte-compile nil
           js2-basic-offset preferred-javascript-indent-level
           js2-indent-on-enter-key t
           js2-auto-indent-p t
           js2-bounce-indent-p nil)
     (after 'js2-mode
       (add-hook 'js2-mode-hook '(lambda() (setq mode-name "JS2")))
       (js2-imenu-extras-setup))

     ;; js-mode
     (setq js-indent-level preferred-javascript-indent-level)
     (setq javascript-indent-level preferred-javascript-indent-level)

     ;; node interpreter
     (add-to-list 'interpreter-mode-alist (cons "node" preferred-javascript-mode))

     ;; coffeescript
     (after 'coffee-mode
       (setq coffee-js-mode preferred-javascript-mode
             coffee-tab-width preferred-javascript-indent-level))

     (add-to-list 'auto-mode-alist '("\\.coffee\\.erb\\'" . coffee-mode))
   #+END_SRC
** Text Group
   The languages/modes that belong to this group include =textile=, =markdown=, etc.
    #+BEGIN_SRC emacs-lisp
      (preamble/checkpoint "enabled support for =text-group=")
      (preamble/require-packages '(textile-mode markdown-mode))

      ;; textile
      (autoload 'textile-mode "textile-mode" "Mode for editing Textile documents" t)
      (setq auto-mode-alist
            (cons '("\\.textile\\'" . textile-mode) auto-mode-alist))

      ;; markdown
      (setq auto-mode-alist
            (cons '("\\.\\(md\\|markdown\\)\\'" . markdown-mode) auto-mode-alist))
    #+END_SRC
** XML Group
   This languages/modes that belong to this group include =xml=, =rss=, =xslt=, etc.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "enabled support for =xml-group")
     (add-to-list 'auto-mode-alist
       (concat "\\." (regexp-opt
         '("xml" "xsd" "sch" "rng" "xslt" "svg" "rss" "gpx" "tcx")) "\\'") 'nxml-mode)

     ;; generic xml mode
     (setq magic-mode-alist (cons '("<\\?xml " . nxml-mode) magic-mode-alist))
     (fset 'xml-mode 'nxml-mode)
     (add-hook 'nxml-mode-hook (lambda ()
       (set (make-local-variable 'ido-use-filename-at-point) nil)))
     (setq nxml-slash-auto-complete-flag t)

     ;; see: http://sinewalker.wordpress.com/2008/06/26/pretty-printing-xml-with-emacs-nxml-mode/
     (defun pp-xml-region (begin end)
       "Pretty format XML markup in region. The function inserts
     linebreaks to separate tags that have nothing but whitespace
     between them.  It then indents the markup by using nxml's
     indentation rules."
       (interactive "r")
       (save-excursion
         (nxml-mode)
         (goto-char begin)
         (while (search-forward-regexp "\>[ \\t]*\<" nil t)
           (backward-char) (insert "\n"))
         (indent-region begin end)))

     ;; integration with tidy for html + xml
     (preamble/require-package 'tidy)
     (add-hook 'nxml-mode-hook (lambda () (tidy-build-menu nxml-mode-map)))
     (add-hook 'html-mode-hook (lambda () (tidy-build-menu html-mode-map)))


     (add-to-list 'auto-mode-alist '("\\.(jsp|tmpl)\\'" . 'html-mode))

   #+END_SRC
** Design Group
   The languages/modes in this section include =css=, =haml=, etc.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "enabled support for =design-group=")
     (preamble/require-packages '(css-eldoc haml-mode htmlize))

     ;;; colourise hex colors
     (dolist (hook '(css-mode-hook html-mode-hook sass-mode-hook))
       (add-hook hook 'rainbow-mode))
     ;; use eldoc for syntax hints
     (autoload 'turn-on-css-eldoc "css-eldoc")
     (add-hook 'css-mode-hook 'turn-on-css-eldoc)

     ;; to enable Skewer mode, check:
     ;; https://github.com/purcell/emacs.d/blob/master/init-css.el

     ;; SASS, SCSS, and Less
     (preamble/require-packages '(sass-mode scss-mode less-css-mode))
     (setq-default scss-compile-at-save nil)

     ;;; auto-complete CSS keywords
     (after 'auto-complete
       (dolist (hook '(css-mode-hook sass-mode-hook scss-mode-hook))
         (add-hook hook 'ac-css-mode-setup)))
   #+END_SRC
** Lisp Group
   The languages/modes in this section include =lisp= and =elisp=.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "enabled support for =lisp-group=")
     (preamble/require-packages '(elisp-slime-nav lively pretty-mode
                                                  auto-compile hl-sexp
                                                  rainbow-delimiters redshank
                                                  macrostep))

     (autoload 'turn-on-pretty-mode "pretty-mode")
     (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
       (add-hook hook 'elisp-slime-nav-mode))

     ;; `hippie-expand' feature
     (defun set-up-hippie-expand-for-elisp ()
       "Locally set `hippie-expand' completion functions for use with Emacs Lisp."
       (make-local-variable 'hippie-expand-try-functions-list)
       (add-to-list 'hippie-expand-try-functions-list 'try-complete-lisp-symbol t)
       (add-to-list 'hippie-expand-try-functions-list 'try-complete-lisp-symbol-partially t))

     ;; automatic byte compilation
     (auto-compile-on-save-mode 1)
     (auto-compile-on-load-mode 1)

     ;; highlight current sexp
     ;; prevent flickery behaviour due to `hl-sexp-mode' unhighlighting before each command
     (after 'hl-sexp
       (defadvice hl-sexp-mode (after unflicker (&optional turn-on) activate)
         (when turn-on
           (remove-hook 'pre-command-hook #'hl-sexp-unhighlight))))

     ;; enable desired features for all lisp modes
     (after 'redshank (diminish 'redshank-mode))

     (defun preamble/lisp-setup ()
       "Enable features useful in any Lisp mode."
       (rainbow-delimiters-mode t)
       (enable-paredit-mode)
       (turn-on-eldoc-mode)
       (redshank-mode))

     (defun preamble/emacs-lisp-setup ()
       "Enable features useful when working with elisp."
       (elisp-slime-nav-mode t)
       (set-up-hippie-expand-for-elisp)
       (ac-emacs-lisp-mode-setup))

     (defconst preamble/elispy-modes
       '(emacs-lisp-mode ielm-mode)
       "Major modes relating to elisp.")

     (defconst preamble/lispy-modes
       (append preamble/elispy-modes
               '(lisp-mode inferior-lisp-mode lisp-interaction-mode))
       "All lispy major modes.")

     (require 'derived)

     (dolist (hook (mapcar #'derived-mode-hook-name preamble/lispy-modes))
       (add-hook hook 'preamble/lisp-setup))

     (dolist (hook (mapcar #'derived-mode-hook-name preamble/elispy-modes))
       (add-hook hook 'preamble/emacs-lisp-setup))

     (defun preamble/maybe-check-parens ()
       "Run `check-parens' if this is a lispy mode."
       (when (memq major-mode preamble/lispy-modes)
         (check-parens)))

     (add-hook 'after-save-hook #'preamble/maybe-check-parens)

     (add-to-list 'auto-mode-alist '("\\.emacs-project\\'" . emacs-lisp-mode))
     (add-to-list 'auto-mode-alist '("archive-contents\\'" . emacs-lisp-mode))

     (define-key emacs-lisp-mode-map (kbd "C-x C-a") 'pp-macroexpand-last-sexp)
     (define-key emacs-lisp-mode-map (kbd "C-x C-e") 'pp-eval-last-sexp)

     (after 'lisp-mode
       (define-key emacs-lisp-mode-map (kbd "C-c e") 'macrostep-expand))
   #+END_SRC
** Miscelleneous
   The languages/modes that belong to this group include =crontab=, =sql=, etc.
   #+BEGIN_SRC emacs-lisp
     (preamble/checkpoint "enabled support for =miscelleneous-group=")
     (preamble/require-packages '( crontab-mode
                                   csv-mode csv-nav
                                   sql-indent ))

     ;; crontab
     (add-to-list 'auto-mode-alist '("\\.?cron\\(tab\\)?\\'" . 'crontab-mode))

     ;; csv
     (add-to-list 'auto-mode-alist '("\\.[Cc][Ss][Vv]\\'" . 'csv_mode))
     (setq csv-separators '("," ";" "|" " "))

     ;; sql
     (after 'sql
       (require 'sql-indent)
       (when (package-installed-p 'dash-at-point)
         (defun preamble/maybe-set-dash-db-docset ()
           (when (eq sql-product 'postgres)
             (setq dash-at-point-docset "psql")))

         (add-hook 'sql-mode-hook 'preamble/maybe-set-dash-db-docset)
         (add-hook 'sql-interactive-mode-hook 'preamble/maybe-set-dash-db-docset)
         (defadvice sql-set-product (after set-dash-docset activate)
           (preamble/maybe-set-dash-db-docset))))

     (setq-default sql-input-ring-file-name
        (expand-file-name ".sqli_history" preamble-dir))

   #+END_SRC
* Session Management
  #+BEGIN_SRC emacs-lisp
    ;; save a list of open files in ~/.emacs.d/.emacs.desktop
    (setq desktop-path (list preamble-dir))
    (desktop-save-mode 1)

    (defadvice desktop-read (around trace-desktop-errors activate)
      (let ((debug-on-error t))
        ad-do-it))
    (defadvice desktop-read (around time-restore activate)
      (let ((start-time (current-time)))
        (prog1
            ad-do-it
          (message "Desktop restored in %.2fms"
                   (preamble/time-subtract-millis (current-time)
                                                  start-time)))))

    (defadvice desktop-create-buffer (around time-create activate)
      (let ((start-time (current-time))
            (filename (ad-get-arg 1)))
        (prog1
            ad-do-it
          (message "Desktop: %.2fms to restore %s"
                   (preamble/time-subtract-millis (current-time)
                                                  start-time)
                   (when filename
                     (abbreviate-file-name filename))))))

    ;; restore histories and registers after saving
    (preamble/require-package 'session)

    (setq session-save-file (expand-file-name ".session" preamble-dir))
    (add-hook 'after-init-hook 'session-initialize)

    ;; save a bunch of variables to the desktop file
    ;; for lists specify the len of the maximal saved data also
    (setq desktop-globals-to-save
          (append '((extended-command-history . 30)
                    (file-name-history        . 100)
                    (ido-last-directory-list  . 100)
                    (ido-work-directory-list  . 100)
                    (ido-work-file-list       . 100)
                    (grep-history             . 30)
                    (compile-history          . 30)
                    (minibuffer-history       . 50)
                    (query-replace-history    . 60)
                    (read-expression-history  . 60)
                    (regexp-history           . 60)
                    (regexp-search-ring       . 20)
                    (search-ring              . 20)
                    (comint-input-ring        . 50)
                    (shell-command-history    . 50)
                    desktop-missing-file-warning
                    tags-file-name
                    register-alist)))

    (when (eval-when-compile (string< emacs-version "24.3.50"))
      (unless (boundp 'desktop-restore-frames)
        (preamble/require-package 'frame-restore)
        (frame-restore)))


  #+END_SRC
* Environment Specific
  I, often, work on more than one environment (machine), and need
  special setup on such machines, sometimes.

** OSX
    When working on my Macbook Pro '13, I prefer my keys to work a bit
    differently, and want some opitons to behave differently. The following
    code summarises so:

    #+BEGIN_SRC emacs-lisp
      (when *is-mac*
        (preamble/checkpoint "configured Emacs Preamble' for Mac OSX..")
        (setq-default locate-command "mdfind")
        (setq mac-command-modifier 'meta)
        (setq mac-option-modifier 'none)
        (setq default-input-method "MacOSX")
        ;; make mouse wheel / trackpad scrolling less jerky
        (setq mouse-wheel-scroll-amount '(0.001)))

      ;; when using cocoa-emacs
      (when *is-mac-gui*
        (preamble/checkpoint "configured Emacs' Preamble for Cocoa Emacs..")
        ;; Woohoo!!
        (global-set-key (kbd "M-`") 'ns-next-frame)
        (global-set-key (kbd "M-h") 'ns-do-hide-emacs)
        ;; what describe-key reports for cmd-option-h
        (global-set-key (kbd "M-ˍ") 'ns-do-hide-others)
        (after-load 'nxml-mode
          (define-key nxml-mode-map (kbd "M-h") nil)))
    #+END_SRC
* Key Bindings
  Key Bindings are loaded from another =org-mode= [[file:./preamble/keybindings.org][file]], which basically lists them as an =org-mode=
  table, and then, uses a function to define the keybindings on the fly.
  #+BEGIN_SRC emacs-lisp
    (preamble/org-babel-load-file "core/keybindings")
  #+END_SRC
* Server
  Allow =emacsclient= to connect to the current =emacs= instance.
  #+BEGIN_SRC emacs-lisp
    (require 'server)
    (unless (server-running-p)
      (server-start))
  #+END_SRC
* Updates
  Emacs' Preamble is really smart! It can update itself, on the go.

  #+BEGIN_SRC emacs-lisp
  (defun preamble/recompile-init ()
    "Byte-compile all your dotfiles again."
    (interactive)
    (byte-recompile-directory preamble-dir 0))

  (defun preamble/update ()
    "Update Preamble to its latest version."
    (interactive)
    (when (y-or-n-p "Do you want to update Preamble? ")
      (message "Updating Preamble...")
      (cd preamble-dir)
      (shell-command "git pull")
      (preamble/recompile-init)
      (message "Update finished. Restart Emacs to complete the process.")))
  #+END_SRC

** TODO there should be a scheduler to automatically check for updates.

* Epilogues
  Things that need to be run at the end of the configuration have been specified here.
  #+BEGIN_SRC emacs-lisp
    ; (require 'init-locales)
  #+END_SRC
* Other Tasks
** TODO show total load time when Emacs has initialized in the mini-buffer
   maybe we can use the function which prelude uses
** TODO tangling should only be done when changes are detected
   This file should only be tangled when changes are detected to this file. This can be done by
   generating MD5 hash of the current file, and then calling appropriate function to call either the
   =readme.el= or =readme.org= for initialization purpose.
** TODO magit should be colorful
** TODO whitespace related settings should only take place in prog-mode
** TODO Org Block: Only colorize till fill column indicator
** TODO Quick Scratch for current mode
    A hotkey should create a new =*scratch*= buffer with mode set to the
    current mode. Moreover, I should be able to press =C-c C-c= to execute the
    current line/expression there in (kinda like a repl within Emacs)
** TODO mousewheel should be able to move up and down in buffer - cursor being at same place.
** DONE Delete trailing whitespace on save
** TODO ^L to <hl>: <hl> spans more than one line
** TODO fci-mode should take care of blocks, as well.
** TODO fci-mode does not work in GUI mode
** TODO visual bell should appear inside mini-buffer
** TODO *Messages* buffer should use =org-mode=
** TODO Distraction free mode?
** TODO jump to the location of last edit
** TODO org-mode export as html should syntax-highlight the code natively
** TODO ensure that emacs is started maximized
